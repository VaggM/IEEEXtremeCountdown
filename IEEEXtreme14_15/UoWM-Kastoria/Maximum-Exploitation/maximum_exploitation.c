//
//   CSAcademy Problem - Maximum Exploitation
//   From: IEEEXtreme 15.0
//   Solved By: Dimitrios and Petros Papakonstantinou
//   Submission Score: 100/100 (113ms - 4392KB)
//

#include <stdio.h>

// Define a constant maximum size for the grid (1001x1001)
#define MAX_SIZE 1001

// Inline function to return the maximum of two integers
int inline max(int a, int b) { return (a > b) ? a : b; }

int main() {
  int row, col, x, y;
  int rowMax[MAX_SIZE] = {0};        // Store the max sums for each row
  int colMax[MAX_SIZE] = {0};        // Store the max sums for each column
  int sum[MAX_SIZE][MAX_SIZE] = {0}; // 2D prefix sum array

  // Read number of rows and columns
  if (scanf("%d %d", &row, &col) != 2) {
    printf("Invalid row and col input\n");
    return 1;
  }

  // Read the dimensions of the submatrices (x and y)
  if (scanf("%d %d", &x, &y) != 2) {
    printf("Invalid x and y input\n");
    return 1;
  }

  // Validate input dimensions to prevent overflow or invalid sizes
  if (row == 0 || col == 0 || x == 0 || y == 0 || row >= MAX_SIZE ||
      col >= MAX_SIZE) {
    printf("Invalid dimensions\n");
    return 1;
  }

  // Loop through each cell of the grid
  for (int r = 1; r <= row; r++) {
    // Update rowMax to keep track of the maximum row sum so far
    rowMax[r] = max(rowMax[r], rowMax[r - 1]);

    for (int c = 1; c <= col; c++) {
      int value;

      // Read the value for the current cell
      if (scanf("%d", &value) != 1) {
        printf("Invalid input value\n");
        return 1;
      }

      // Update column max to track the maximum column sum so far
      colMax[c] = max(colMax[c], colMax[c - 1]);

      // Compute the prefix sum for the current cell
      sum[r][c] = value - sum[r - 1][c - 1] + sum[r][c - 1] + sum[r - 1][c];

      // Check if we can calculate the sum of the submatrix with dimensions (x,
      // y) ending at (r, c)
      if (r >= x && c >= y) {
        int xySum =
            sum[r][c] - sum[r - x][c] - sum[r][c - y] + sum[r - x][c - y];
        rowMax[r] = max(rowMax[r], xySum); // Update max sum for this row
        colMax[c] = max(colMax[c], xySum); // Update max sum for this column
      }

      // Similarly, check if we can calculate the sum of the submatrix with
      // dimensions (y, x) ending at (r, c)
      if (r >= y && c >= x) {
        int yxSum =
            sum[r][c] - sum[r - y][c] - sum[r][c - x] + sum[r - y][c - x];
        rowMax[r] = max(rowMax[r], yxSum); // Update row max
        colMax[c] = max(colMax[c], yxSum); // Update column max
      }
    }
  }

  int ans = 0; // Variable to store the maximum answer

  // Iterate again through each cell to compute the final answer
  for (int r = 1; r <= row; r++) {
    for (int c = 1; c <= col; c++) {
      // Calculate sum of the submatrix (x, y) at (r, c) and update the answer
      if (r >= x && c >= y) {
        int xySum =
            sum[r][c] - sum[r - x][c] - sum[r][c - y] + sum[r - x][c - y];
        ans = max(ans, xySum + max(rowMax[r - x], colMax[c - y]));
      }

      // Calculate sum of the submatrix (y, x) at (r, c) and update the answer
      if (r >= y && c >= x) {
        int yxSum =
            sum[r][c] - sum[r - y][c] - sum[r][c - x] + sum[r - y][c - x];
        ans = max(ans, yxSum + max(rowMax[r - y], colMax[c - x]));
      }
    }
  }

  // Output the maximum submatrix sum
  printf("%d\n", ans);
  return 0;
}
