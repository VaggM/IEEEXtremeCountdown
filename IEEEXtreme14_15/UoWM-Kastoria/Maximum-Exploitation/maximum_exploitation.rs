//
//   CSAcademy Problem - Maximum Exploitation
//   From: IEEEXtreme 15.0
//   Solved By: Dimitrios and Petros Papakonstantinou
//   Submission Score: 100/100 (40ms - 4520KB)
//

use std::cmp::max;
use std::io::{self, BufRead};

fn main() -> io::Result<()> {
    let stdin = io::stdin();
    let mut lines = stdin.lock().lines();

    // Read row and col (the first line of input, representing the grid dimensions)
    let dimensions: Vec<usize> = lines
        .next() // Fetch the first line
        .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidInput, "Missing row and col input"))?? // Error if the line is missing
        .split_whitespace() // Split the line into words (space-separated)
        .map(|s| s.parse().unwrap_or(0)) // Parse the words into integers
        .collect();

    // Ensure we have two values for row and col
    if dimensions.len() < 2 {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "Invalid row and col input",
        ));
    }

    let (row, col) = (dimensions[0], dimensions[1]);

    // Read x and y (second line of input, representing the submatrix dimensions)
    let xy: Vec<usize> = lines
        .next() // Fetch the second line
        .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidInput, "Missing x and y input"))??
        .split_whitespace() // Split the line into words
        .map(|s| s.parse().unwrap_or(0)) // Parse the words into integers
        .collect();

    // Ensure we have two values for x and y
    if xy.len() < 2 {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "Invalid x and y input",
        ));
    }

    let (x, y) = (xy[0], xy[1]);

    // Check for invalid dimensions (grid or submatrices cannot be 0)
    if row == 0 || col == 0 || x == 0 || y == 0 {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "Invalid dimensions",
        ));
    }

    // Initialize arrays to store the maximum sum for each row and column
    let mut row_max = vec![0; row + 1]; // Store max submatrix sums for rows (1-indexed)
    let mut col_max = vec![0; col + 1]; // Store max submatrix sums for columns (1-indexed)

    // 2D array to store prefix sums of the matrix
    let mut sum = vec![vec![0; col + 1]; row + 1]; // Prefix sum matrix (1-indexed)

    // Iterate through each row of the matrix
    for r in 1..=row {
        // Update the row_max value for the current row
        row_max[r] = max(row_max[r], row_max[r - 1]);

        // Read the current row's values
        let values: Vec<i32> = lines
            .next() // Fetch the next line of values
            .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidInput, "Missing input line"))??
            .split_whitespace() // Split into individual values
            .map(|s| s.parse().unwrap_or(0)) // Parse each value into an integer
            .collect();

        // Ensure the row has enough values
        if values.len() < col {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "Insufficient values in row",
            ));
        }

        // Iterate through the columns in the current row
        for (c, &value) in values.iter().enumerate().take(col).map(|(i, v)| (i + 1, v)) {
            // Update the col_max value for the current column
            col_max[c] = max(col_max[c], col_max[c - 1]);

            // Update the prefix sum for the current cell (sum[r][c])
            // The formula is: sum[r][c] = current value - top-left diagonal + left + top
            sum[r][c] = value - sum[r - 1][c - 1] + sum[r][c - 1] + sum[r - 1][c];

            // Check if we can calculate the sum for a submatrix of size (x, y) ending at (r, c)
            if r >= x && c >= y {
                let xy_sum = sum[r][c] - sum[r - x][c] - sum[r][c - y] + sum[r - x][c - y];
                row_max[r] = max(row_max[r], xy_sum); // Update the max sum for the current row
                col_max[c] = max(col_max[c], xy_sum); // Update the max sum for the current column
            }

            // Check if we can calculate the sum for a submatrix of size (y, x) ending at (r, c)
            if r >= y && c >= x {
                let yx_sum = sum[r][c] - sum[r - y][c] - sum[r][c - x] + sum[r - y][c - x];
                row_max[r] = max(row_max[r], yx_sum); // Update the max sum for the current row
                col_max[c] = max(col_max[c], yx_sum); // Update the max sum for the current column
            }
        }
    }

    // Calculate the final answer by checking the sums of all valid submatrices
    let mut ans = 0;

    for r in 1..=row {
        for c in 1..=col {
            // Check for submatrices of size (x, y)
            if r >= x && c >= y {
                let xy_sum = sum[r][c] - sum[r - x][c] - sum[r][c - y] + sum[r - x][c - y];
                ans = max(ans, xy_sum + max(row_max[r - x], col_max[c - y]));
            }

            // Check for submatrices of size (y, x)
            if r >= y && c >= x {
                let yx_sum = sum[r][c] - sum[r - y][c] - sum[r][c - x] + sum[r - y][c - x];
                ans = max(ans, yx_sum + max(row_max[r - y], col_max[c - x]));
            }
        }
    }

    // Output the maximum sum of any valid submatrix
    println!("{}", ans);
    Ok(())
}
